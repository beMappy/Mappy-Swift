// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Mappy
import ArcGIS
import CocoaLumberjack
import Combine
import Foundation
import KeychainAccess
@_exported import Mappy
import Swift
import Swinject
import UIKit
import ZIPFoundation
import _Concurrency
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class MapView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var map: Mappy.Map? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.MapView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.MapView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreGraphics.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.MapView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
public struct Building : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String {
    case chalet
    case hotelLobby
    case lodge
    case restaurant
    case restroom
    case skiPatrol
    case other
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.Building.Category?
  public let url: Swift.String?
  public let phone: Swift.String?
  public let facilityId: Swift.String?
  public static let any: Mappy.Building
  public init(name: Swift.String, category: Mappy.Building.Category?, url: Swift.String?, phone: Swift.String?, facilityId: Swift.String?)
  public static func == (a: Mappy.Building, b: Mappy.Building) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Scene {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.SceneError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
}
public struct SkiLift : Swift.Equatable, Swift.Hashable {
  public enum LiftType : Swift.String {
    case magicCarpet
    case towRope
    case chairLift2
    case chairLift3
    case chairLift4
    case chairLift5
    case chairLift6
    case gondola
    case tram
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PassengerPosition : Swift.String {
    case sit
    case stand
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var displayName: Swift.String {
    get
  }
  public let name: Swift.String
  public let liftType: Mappy.SkiLift.LiftType?
  public let passengerPosition: Mappy.SkiLift.PassengerPosition?
  public let length: Swift.Double?
  public let travelTime: Swift.Double?
  public var liftNumber: Swift.Int?
  public static let any: Mappy.SkiLift
  public init(name: Swift.String, liftNumber: Swift.Int?, liftType: Mappy.SkiLift.LiftType?, passengerPosition: Mappy.SkiLift.PassengerPosition?, length: Swift.Double?, travelTime: Swift.Double?)
  public static func == (a: Mappy.SkiLift, b: Mappy.SkiLift) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VenuesService {
  public init()
  public func getVenues() -> Combine.AnyPublisher<[Mappy.Venue], Mappy.VenuesProviderError>
  public func getVenue(venueId: Swift.String) -> Combine.AnyPublisher<Mappy.Venue?, Mappy.VenuesProviderError>
  @objc deinit
}
final public class Scene : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  public init(sceneInfo: Mappy.Venue)
  @objc deinit
}
public enum SceneError : Foundation.LocalizedError {
  case objectNotFound
  case identifierNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol Serializable : Swift.Decodable, Swift.Encodable {
  func serialize() -> Foundation.Data?
}
extension Mappy.Serializable {
  public func serialize() -> Foundation.Data?
}
public struct BuildingAmenity : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String, Swift.Comparable {
    case foodAndBeverage
    case retail
    case firstAid
    case other
    case accommodations
    case guestServices
    case transportation
    case baseArea
    case skiFeature
    case information
    public static func < (lhs: Mappy.BuildingAmenity.Category, rhs: Mappy.BuildingAmenity.Category) -> Swift.Bool
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Subtype : Swift.String {
    case bar
    case fullService
    case casual
    case ticketOffice
    case rentalShop
    case repairShop
    case retailStore
    case zipTours
    case skiPatrol
    case aed
    case restroom
    case skiSchool
    case kidZones
    case lockers
    case restArea
    case adaAccessible
    case other
    case shuttleStop
    case transportation
    case rentals
    case atm
    case hotel
    case condo
    case information
    case baseArea
    case village
    case villageNoDetail
    case racingArena
    case terrainPark
    case guestServices
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.BuildingAmenity.Category?
  public let subtype: Mappy.BuildingAmenity.Subtype?
  public let buildingId: Swift.Int?
  public let buildingName: Swift.String?
  public let levelId: Swift.String?
  public let url: Swift.String?
  public let phone: Swift.String?
  public static let any: Mappy.BuildingAmenity
  public init(name: Swift.String, category: Mappy.BuildingAmenity.Category?, subtype: Mappy.BuildingAmenity.Subtype?, buildingId: Swift.Int?, buildingName: Swift.String?, levelId: Swift.String?, url: Swift.String?, phone: Swift.String?)
  public static func == (a: Mappy.BuildingAmenity, b: Mappy.BuildingAmenity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum FeatureCategory : Swift.Equatable, Swift.Hashable {
  case skiSlope(Mappy.SkiSlope)
  case skiLift(Mappy.SkiLift)
  case building(Mappy.Building)
  case amenity(Mappy.BuildingAmenity)
  case bookmark(Mappy.Bookmark)
  public var name: Swift.String {
    get
  }
  public static func == (a: Mappy.FeatureCategory, b: Mappy.FeatureCategory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Environment : Swift.String, Mappy.Serializable {
  case DEV, TST, STG, PRD
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SkiSlope : Swift.Equatable, Swift.Hashable {
  public enum Level : Swift.Int, Swift.Comparable, Swift.CaseIterable, Swift.Identifiable {
    public static func < (lhs: Mappy.SkiSlope.Level, rhs: Mappy.SkiSlope.Level) -> Swift.Bool
    case beginner, intermediate, advanced, expert
    public var id: Swift.Int {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [Mappy.SkiSlope.Level]
    public typealias ID = Swift.Int
    public typealias RawValue = Swift.Int
    public static var allCases: [Mappy.SkiSlope.Level] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum RunType : Swift.String {
    case walkingPath
    case mainRun
    case connectorTrail
    case nordicTrail
    case catwalk
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let level: Mappy.SkiSlope.Level?
  public let runType: Mappy.SkiSlope.RunType?
  public let length: Swift.Double?
  public let averageSlope: Swift.Double?
  public let averageSpeed: Swift.Double?
  public let travelTime: Swift.Double?
  public let extremeCondition: Swift.Bool?
  public static let any: Mappy.SkiSlope
  public init(name: Swift.String, level: Mappy.SkiSlope.Level?, runType: Mappy.SkiSlope.RunType?, length: Swift.Double?, averageSlope: Swift.Double?, averageSpeed: Swift.Double?, travelTime: Swift.Double?, extremeCondition: Swift.Bool?)
  public static func == (a: Mappy.SkiSlope, b: Mappy.SkiSlope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Loadable {
  var loadStatus: Mappy.LoadStatus { get }
}
public enum LoadStatus {
  case loaded
  case loading
  case failedToLoad
  case notLoaded
  case unknown
  public static func == (a: Mappy.LoadStatus, b: Mappy.LoadStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MappyCore {
  public static func initialize(clientId: Swift.String, secret: Swift.String) -> Combine.AnyPublisher<Swift.Void, Mappy.MappyCoreError>
  @objc deinit
}
public enum MappyCoreError : Foundation.LocalizedError {
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct Venue {
  public let resortId: Swift.String
  public let data: Mappy.VenueData?
}
public struct VenueData {
  public let baseElevation: Swift.Int?
  public let gondolaCount: Swift.Int?
  public let skiableArea: Swift.Int?
  public let skiPatrolEmergencyNumber: Swift.String?
  public let terrainParkCount: Swift.Int?
  public let verticalElevation: Swift.Int?
  public let ziplineCount: Swift.Int?
  public let liftCount: Swift.Int?
  public let name: Swift.String?
  public let description: Swift.String?
  public let geoReference: Mappy.VenueGeoReference?
  public let terrainPercentage: Mappy.VenueTerrainPercentage?
  public let queryParamResortName: Swift.String?
}
public struct VenueGeoReference {
  public let minY: Swift.Double?
  public let minX: Swift.Double?
  public let maxY: Swift.Double?
  public let maxX: Swift.Double?
}
public struct VenueTerrainPercentage {
  public let intermediate: Swift.Float?
  public let advanced: Swift.Float?
  public let beginer: Swift.Float?
}
public struct VenueMap {
  public enum MapType : Swift.String {
    case map
    case scene
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum VenuesProviderError : Foundation.LocalizedError {
  case objectNotFound
  case venuesNotFound
  case venueNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.SceneView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
}
final public class Map : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  public init(mapInfo: Mappy.Venue)
  @objc deinit
}
public enum MapError : Foundation.LocalizedError {
  case objectNotFound
  case identifierNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.Map {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.MapError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
}
public struct Feature : Swift.Identifiable, Swift.Equatable, Swift.Hashable {
  public let id: Foundation.UUID
  public let category: Mappy.FeatureCategory
  public var associatedFeatures: Swift.Set<Mappy.Feature>
  public static func == (a: Mappy.Feature, b: Mappy.Feature) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Foundation.UUID
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.MapView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class SceneView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var scene: Mappy.Scene? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.SceneView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.SceneView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreGraphics.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.SceneView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
public struct Bookmark : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String {
    case village
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.Bookmark.Category?
  public static let any: Mappy.Bookmark
  public static func == (a: Mappy.Bookmark, b: Mappy.Bookmark) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Building.Category : Swift.Equatable {}
extension Mappy.Building.Category : Swift.Hashable {}
extension Mappy.Building.Category : Swift.RawRepresentable {}
extension Mappy.SkiLift.LiftType : Swift.Equatable {}
extension Mappy.SkiLift.LiftType : Swift.Hashable {}
extension Mappy.SkiLift.LiftType : Swift.RawRepresentable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Equatable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Hashable {}
extension Mappy.SkiLift.PassengerPosition : Swift.RawRepresentable {}
extension Mappy.BuildingAmenity.Category : Swift.Hashable {}
extension Mappy.BuildingAmenity.Category : Swift.RawRepresentable {}
extension Mappy.BuildingAmenity.Subtype : Swift.Equatable {}
extension Mappy.BuildingAmenity.Subtype : Swift.Hashable {}
extension Mappy.BuildingAmenity.Subtype : Swift.RawRepresentable {}
extension Mappy.Environment : Swift.Equatable {}
extension Mappy.Environment : Swift.Hashable {}
extension Mappy.Environment : Swift.RawRepresentable {}
extension Mappy.SkiSlope.Level : Swift.Hashable {}
extension Mappy.SkiSlope.Level : Swift.RawRepresentable {}
extension Mappy.SkiSlope.RunType : Swift.Equatable {}
extension Mappy.SkiSlope.RunType : Swift.Hashable {}
extension Mappy.SkiSlope.RunType : Swift.RawRepresentable {}
extension Mappy.LoadStatus : Swift.Equatable {}
extension Mappy.LoadStatus : Swift.Hashable {}
extension Mappy.VenueMap.MapType : Swift.Equatable {}
extension Mappy.VenueMap.MapType : Swift.Hashable {}
extension Mappy.VenueMap.MapType : Swift.RawRepresentable {}
extension Mappy.Bookmark.Category : Swift.Equatable {}
extension Mappy.Bookmark.Category : Swift.Hashable {}
extension Mappy.Bookmark.Category : Swift.RawRepresentable {}
