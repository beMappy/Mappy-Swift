// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name Mappy
import AVFoundation
import ArcGIS
import CocoaLumberjack
import CocoaLumberjackSwift
import Combine
import CoreLocation
import DeveloperToolsSupport
import Foundation
import KeychainAccess
@_exported import Mappy
import PusherSwift
import Reachability
import RealmSwift
import Swift
import SwiftUI
import Swinject
import UIKit
import ZIPFoundation
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol TrackingProvider {
  var appTrackingInfo: Mappy.AppTrackingInfo? { get set }
  var isTracking: Swift.Bool { get }
  func resume(appTrackingInfo: Mappy.AppTrackingInfo?)
  func suspend()
  func autoSuspendAndResume(whenCrossingBoundaryOf map: Mappy.Map) throws
  func cancelAutoSuspendAndResume(whenCrossingBoundaryOf map: Mappy.Map)
  func evaluateAutoTrackedBoundaries()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class MapView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var map: Mappy.Map? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.MapView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var interactionOptions: Mappy.MapViewInteractionOptions {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.MapView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreFoundation.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.MapView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
public struct UserLocation : Mappy.Serializable {
  public let userId: Swift.String
  public let lat: Swift.Double
  public let long: Swift.Double
  public let unixDate: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Building : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String {
    case chalet
    case hotelLobby
    case lodge
    case restaurant
    case restroom
    case skiPatrol
    case other
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let buildingId: Swift.Int?
  public let name: Swift.String
  public let category: Mappy.Building.Category?
  public let url: Swift.String?
  public let phone: Swift.String?
  public let facilityId: Swift.String?
  public let foreignId: Swift.String?
  public let foreignSource: Swift.String?
  public static let any: Mappy.Building
  public init(buildingId: Swift.Int?, name: Swift.String, category: Mappy.Building.Category?, url: Swift.String?, phone: Swift.String?, facilityId: Swift.String?, foreignId: Swift.String?, foreignSource: Swift.String?)
  public static func == (a: Mappy.Building, b: Mappy.Building) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RouteTracker {
  final public var onEvent: Combine.PassthroughSubject<Mappy.RouteTracker.Event, Swift.Never>
  final public var recentResponse: Mappy.TurnByTurnNavigationResponse?
  final public var voiceDirectionsActive: Swift.Bool {
    get
    set
  }
  final public var currentStep: Mappy.NavigationUpcomingDirection? {
    get
  }
  final public var nextStep: Mappy.NavigationUpcomingDirection? {
    get
  }
  final public var remainingTime: Swift.String {
    get
  }
  final public var routeDifficulty: Mappy.SkiSlope.Level {
    get
  }
  final public var totalRouteDistance: Swift.String {
    get
  }
  final public var startingPoint: Swift.String {
    get
  }
  final public var steps: [Mappy.NavigationStep] {
    get
  }
  final public var endingPoint: Swift.String {
    get
  }
  @objc deinit
}
extension Mappy.RouteTracker {
  public enum Event {
    case onError(any Swift.Error)
    case onTurnByTurnNavigationResponse(Mappy.TurnByTurnNavigationResponse)
    case didReroute(Mappy.RouteResponse)
    case didReachDestination
  }
}
public struct NavigationUpcomingDirection {
  public var directionManeuverType: Mappy.DirectionManeuverType {
    get
  }
  public let distance: Swift.String
}
public enum DirectionManeuverType {
  case unknown, stop, straight, bearLeft, bearRight, turnLeft, turnRight, sharpLeft, sharpRight, uTurn, ferry, roundabout, highwayMerge, highwayExit, highwayChange, forkCenter, forkLeft, forkRight, depart, tripItem, endOfFerry, rampRight, rampLeft, turnLeftRight, turnRightLeft, turnRightRight, turnLeftLeft, pedestrianRamp, elevator, escalator, stairs, doorPassage
  public static func == (a: Mappy.DirectionManeuverType, b: Mappy.DirectionManeuverType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Scene {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.SceneError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func destroy()
}
public struct SceneViewInteractionOptions {
}
public protocol TracksProvider {
  func renderUserTracks(on geoModel: ArcGIS.AGSGeoModel, layerId: Swift.String, userId: Swift.String?, venueId: Swift.String, startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval) -> Combine.AnyPublisher<ArcGIS.AGSFeatureLayer, Mappy.TracksProviderError>
}
public enum TracksProviderError : Foundation.LocalizedError {
  case objectNotFound
  case requestConfigFailure
  case unableToLoadTracks
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct Group : Swift.Equatable, Swift.Hashable {
  public let groupId: Swift.String
  public let groupCode: Swift.String
  public let name: Swift.String
  public let users: [Mappy.GroupUser]
  public static func == (a: Mappy.Group, b: Mappy.Group) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SkiLift : Swift.Equatable, Swift.Hashable {
  public enum LiftType : Swift.String {
    case magicCarpet
    case towRope
    case chairLift2
    case chairLift3
    case chairLift4
    case chairLift5
    case chairLift6
    case gondola
    case tram
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PassengerPosition : Swift.String {
    case sit
    case stand
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var displayName: Swift.String {
    get
  }
  public let name: Swift.String
  public let liftType: Mappy.SkiLift.LiftType?
  public let passengerPosition: Mappy.SkiLift.PassengerPosition?
  public let length: Swift.Double?
  public let travelTime: Swift.Double?
  public var liftNumber: Swift.Int?
  public let foreignId: Swift.String?
  public let foreignSource: Swift.String?
  public static let any: Mappy.SkiLift
  public init(name: Swift.String, liftNumber: Swift.Int?, liftType: Mappy.SkiLift.LiftType?, passengerPosition: Mappy.SkiLift.PassengerPosition?, length: Swift.Double?, travelTime: Swift.Double?, foreignId: Swift.String?, foreignSource: Swift.String?)
  public static func == (a: Mappy.SkiLift, b: Mappy.SkiLift) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VenuesService {
  public init()
  public func getVenues() -> Combine.AnyPublisher<[Mappy.Venue], Mappy.VenuesProviderError>
  public func getVenue(venueId: Swift.String) -> Combine.AnyPublisher<Mappy.Venue?, Mappy.VenuesProviderError>
  @objc deinit
}
final public class Scene : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  final public var packageName: Swift.String?
  public init(sceneInfo: any Mappy.SceneInfo)
  @objc deinit
}
public enum SceneError : Foundation.LocalizedError {
  case objectNotFound
  case identifierNotFound
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol SceneInfo {
  var venueId: Swift.String { get }
  var initialExtent3DBookmark: Swift.String? { get }
}
public protocol Serializable : Swift.Decodable, Swift.Encodable {
  func serialize() -> Foundation.Data?
}
extension Mappy.Serializable {
  public func serialize() -> Foundation.Data?
  public func toDictionary() -> [Swift.String : Any]
  public func jsonString() -> Swift.String?
  public init?(from: Any)
}
public struct BuildingAmenity : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let category: Swift.String?
  public let subtype: Swift.String?
  public let buildingId: Swift.Int?
  public let buildingName: Swift.String?
  public let levelId: Swift.String?
  public let url: Swift.String?
  public let phone: Swift.String?
  public let foreignId: Swift.String?
  public let foreignSource: Swift.String?
  public static let any: Mappy.BuildingAmenity
  public init(name: Swift.String, category: Swift.String?, subtype: Swift.String?, buildingId: Swift.Int?, buildingName: Swift.String?, levelId: Swift.String?, url: Swift.String?, phone: Swift.String?, foreignId: Swift.String?, foreignSource: Swift.String?)
  public static func == (a: Mappy.BuildingAmenity, b: Mappy.BuildingAmenity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Bookmark : Swift.Equatable, Swift.Hashable {
  public static let any: Mappy.Bookmark
  public enum Category : Swift.String {
    case village
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.Bookmark.Category?
  public let foreignId: Swift.String?
  public let foreignSource: Swift.String?
  public static func == (a: Mappy.Bookmark, b: Mappy.Bookmark) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct AppTrackingInfo {
  public init(username: Swift.String?, groupIDs: [Swift.String]?, selectedVenue: Swift.String?, difficultyPreference: Swift.String?)
}
public struct UserPinLocation {
  public let userId: Swift.String
  public let icon: UIKit.UIImage
  public let name: Swift.String
  public let lat: CoreLocation.CLLocationDegrees
  public let long: CoreLocation.CLLocationDegrees
  public let unixDate: Swift.Double
  public init(userId: Swift.String, icon: UIKit.UIImage, name: Swift.String, lat: CoreLocation.CLLocationDegrees, long: CoreLocation.CLLocationDegrees, unixDate: Swift.Double)
}
public enum FeatureCategory : Swift.Equatable, Swift.Hashable {
  case skiSlope(Mappy.SkiSlope)
  case skiLift(Mappy.SkiLift)
  case building(Mappy.Building)
  case amenity(Mappy.BuildingAmenity)
  case point(Mappy.Point)
  case bookmark(Mappy.Bookmark)
  public var name: Swift.String {
    get
  }
  public static func == (a: Mappy.FeatureCategory, b: Mappy.FeatureCategory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TrackingService : Mappy.TrackingProvider {
  public static let current: any Mappy.TrackingProvider
  final public var appTrackingInfo: Mappy.AppTrackingInfo?
  final public var isTracking: Swift.Bool {
    get
  }
  final public func resume(appTrackingInfo: Mappy.AppTrackingInfo?)
  final public func suspend()
  final public func autoSuspendAndResume(whenCrossingBoundaryOf map: Mappy.Map) throws
  final public func cancelAutoSuspendAndResume(whenCrossingBoundaryOf map: Mappy.Map)
  final public func evaluateAutoTrackedBoundaries()
  @objc deinit
}
public enum Environment : Swift.String, Mappy.Serializable {
  case DEV, TST, STG, PRD
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class GroupsService {
  public init()
  final public func fetchGroups() -> Combine.AnyPublisher<[Mappy.Group], Mappy.GroupsProviderError>
  final public func fetchGroupInfo(groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func createGroup(name: Swift.String, userRole: Swift.String?) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func updateGroup(groupId: Swift.String, name: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func deleteGroup(groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func addUser(userId: Swift.String, groupCode: Swift.String, userRole: Swift.String?) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func removeUser(userId: Swift.String, groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  @objc deinit
}
public class GroupLocationService {
  final public let onEvent: Combine.PassthroughSubject<Mappy.GroupLocationService.Event, Swift.Never>
  public init()
  public func shareUserLocation() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  public func stopSharingUserLocation()
  public func listenToGroups() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  public func stopListeningToGroups() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  @objc deinit
}
public enum GroupLocationServiceError : Foundation.LocalizedError {
  case objectNotFound
  case clientIdNotFound
  case userIsNotInsideTheVenue
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.GroupLocationService {
  public enum Event {
    case userLocation(Mappy.UserLocation)
    case userAddedToGroup(groupId: Swift.String, userId: Swift.String)
    case userRemovedFromGroup(groupId: Swift.String, userId: Swift.String)
  }
}
public struct SkiSlope : Swift.Equatable, Swift.Hashable {
  public enum Level : Swift.Int, Swift.Comparable, Swift.CaseIterable, Swift.Identifiable {
    public static func < (lhs: Mappy.SkiSlope.Level, rhs: Mappy.SkiSlope.Level) -> Swift.Bool
    case beginner, intermediate, advanced, expert
    public var id: Swift.Int {
      get
    }
    public var name: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [Mappy.SkiSlope.Level]
    public typealias ID = Swift.Int
    public typealias RawValue = Swift.Int
    public static var allCases: [Mappy.SkiSlope.Level] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum RunType : Swift.String {
    case walkingPath
    case mainRun
    case connectorTrail
    case nordicTrail
    case catwalk
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let level: Mappy.SkiSlope.Level?
  public let runType: Mappy.SkiSlope.RunType?
  public let length: Swift.Double?
  public let maxSlope: Swift.Double?
  public let averageSlope: Swift.Double?
  public let averageSpeed: Swift.Double?
  public let travelTime: Swift.Double?
  public let extremeCondition: Swift.Bool?
  public let foreignId: Swift.String?
  public let foreignSource: Swift.String?
  public static let any: Mappy.SkiSlope
  public init(name: Swift.String, level: Mappy.SkiSlope.Level?, runType: Mappy.SkiSlope.RunType?, length: Swift.Double?, maxSlope: Swift.Double?, averageSlope: Swift.Double?, averageSpeed: Swift.Double?, travelTime: Swift.Double?, extremeCondition: Swift.Bool?, foreignId: Swift.String?, foreignSource: Swift.String?)
  public static func == (a: Mappy.SkiSlope, b: Mappy.SkiSlope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Loadable {
  var loadStatus: Mappy.LoadStatus { get }
}
public enum LoadStatus {
  case loaded
  case loading
  case failedToLoad
  case notLoaded
  case unknown
  public static func == (a: Mappy.LoadStatus, b: Mappy.LoadStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MappyCore {
  public static func initialize(clientId: Swift.String, secret: Swift.String, mappyUserId: Swift.String?, deferTracking: Swift.Bool = false, appTrackingInfo: Mappy.AppTrackingInfo? = nil) -> Combine.AnyPublisher<Mappy.MappyMeta, Swift.Never>
  @objc deinit
}
public struct MappyMeta {
  public var mappyUserId: Swift.String?
  public var error: Mappy.MappyCoreError?
}
public enum MappyCoreError : Foundation.LocalizedError {
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct Point : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let latitude: CoreLocation.CLLocationDegrees
  public let longitude: CoreLocation.CLLocationDegrees
  public static let any: Mappy.Point
  public init(name: Swift.String, latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  public static func == (a: Mappy.Point, b: Mappy.Point) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ArcGIS.AGSLocationDataSource : ArcGIS.AGSLocationChangeHandlerDelegate {
  @objc dynamic public func locationDataSource(_ locationDataSource: ArcGIS.AGSLocationDataSource, locationDidChange location: ArcGIS.AGSLocation)
}
extension UIKit.UIImage {
  public static let mappyPinSmall: UIKit.UIImage
  public static let mappyPin: UIKit.UIImage
}
public enum StatsProviderError : Foundation.LocalizedError {
  case objectNotFound
  case invalidPayload
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
final public class StatsService {
  public init()
  final public func getUserStats(userId: Swift.String?, venueId: Swift.String?, startTime: Foundation.TimeInterval?, endTime: Foundation.TimeInterval?) -> Combine.AnyPublisher<Mappy.UserStats, Mappy.StatsProviderError>
  @objc deinit
}
extension Swift.Array : Mappy.Serializable where Element : Swift.Decodable, Element : Swift.Encodable {
}
public struct Venue : Mappy.Serializable {
  public let venueId: Swift.String
  public let data: Mappy.VenueData?
  public init(venueId: Swift.String, data: Mappy.VenueData?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VenueData : Mappy.Serializable {
  public let baseElevation: Swift.Int?
  public let gondolaCount: Swift.Int?
  public let skiableArea: Swift.Int?
  public let skiPatrolEmergencyNumber: Swift.String?
  public let terrainParkCount: Swift.Int?
  public let verticalElevation: Swift.Int?
  public let ziplineCount: Swift.Int?
  public let liftCount: Swift.Int?
  public let name: Swift.String?
  public let description: Swift.String?
  public let geoReference: Mappy.VenueGeoReference?
  public let terrainPercentage: Mappy.VenueTerrainPercentage?
  public let queryParamResortName: Swift.String?
  public let initialExtent2DBookmark: Swift.String?
  public let initialExtent3DBookmark: Swift.String?
  public let maxScale: Swift.Double?
  public let minScale: Swift.Double?
  public init(baseElevation: Swift.Int?, gondolaCount: Swift.Int?, skiableArea: Swift.Int?, skiPatrolEmergencyNumber: Swift.String?, terrainParkCount: Swift.Int?, verticalElevation: Swift.Int?, ziplineCount: Swift.Int?, liftCount: Swift.Int?, name: Swift.String?, description: Swift.String?, geoReference: Mappy.VenueGeoReference?, terrainPercentage: Mappy.VenueTerrainPercentage?, queryParamResortName: Swift.String?, initialExtent2DBookmark: Swift.String?, initialExtent3DBookmark: Swift.String?, maxScale: Swift.Double?, minScale: Swift.Double?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VenueGeoReference : Mappy.Serializable {
  public let minY: Swift.Double?
  public let minX: Swift.Double?
  public let maxY: Swift.Double?
  public let maxX: Swift.Double?
  public init(minY: Swift.Double?, minX: Swift.Double?, maxY: Swift.Double?, maxX: Swift.Double?)
  public func contains(latitude: Swift.Double, longitude: Swift.Double) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VenueTerrainPercentage : Mappy.Serializable {
  public let intermediate: Swift.Float?
  public let advanced: Swift.Float?
  public let beginer: Swift.Float?
  public init(intermediate: Swift.Float?, advanced: Swift.Float?, beginer: Swift.Float?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum MapType : Swift.String {
  case map
  case scene
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Mappy.Venue : Mappy.MapInfo, Mappy.SceneInfo {
  public var initialExtent2DBookmark: Swift.String? {
    get
  }
  public var initialExtent3DBookmark: Swift.String? {
    get
  }
  public var region: Mappy.MapRegion {
    get
  }
  public var maxScale: Swift.Double {
    get
  }
  public var minScale: Swift.Double {
    get
  }
}
public enum VenuesProviderError : Foundation.LocalizedError {
  case objectNotFound
  case venuesNotFound
  case venueNotFound
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.SceneView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
  @_Concurrency.MainActor(unsafe) final public func displayUserPins(using locations: [Mappy.UserPinLocation])
  @_Concurrency.MainActor(unsafe) final public func zoomToLocation(latitude: Swift.Double, longitude: Swift.Double)
}
public struct UserStats {
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let minimumAltitudeInMetres: Swift.Double?
  public let maximumAltitudeInMetres: Swift.Double?
  public let minimumSpeedInMilesPerHour: Swift.Double?
  public let maximumSpeedInMilesPerHour: Swift.Double?
  public let distanceInMetres: Swift.Double?
  public let timeSkiedInMilliSeconds: Swift.Double?
  public let activeHours: Swift.Double?
  public let trackDurationInMilliSeconds: Swift.Double?
  public let trackCount: Swift.Int?
  public let verticalFeetCumulative: Swift.Double?
  public let daysCount: Swift.Int?
  public let daysStats: [Swift.String : Mappy.UserStats]?
}
extension UIKit.UIColor {
  public static let routeHighlight: UIKit.UIColor
  public func withSaturation(setTo saturation: CoreFoundation.CGFloat) -> UIKit.UIColor
}
public struct RouteResponse : Swift.Identifiable, Swift.Equatable {
  public struct RouteStep : Swift.Equatable {
    public var directionManeuver: Mappy.DirectionManeuver {
      get
    }
    public let feature: Mappy.FeatureCategory
    public static func == (a: Mappy.RouteResponse.RouteStep, b: Mappy.RouteResponse.RouteStep) -> Swift.Bool
  }
  public enum TravelType : Swift.CaseIterable {
    case beginner, intermediate, advanced, expert, lift
    public static func == (a: Mappy.RouteResponse.TravelType, b: Mappy.RouteResponse.TravelType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Mappy.RouteResponse.TravelType]
    public static var allCases: [Mappy.RouteResponse.TravelType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let id: Foundation.UUID
  public let origin: Mappy.Feature
  public let destination: Mappy.Feature
  public let steps: [Mappy.RouteResponse.RouteStep]
  public func mostDifficultSkiSlopeLevel() -> Mappy.SkiSlope.Level
  public func travelTypeRatiosByDuration() -> [Mappy.RouteResponse.TravelType : Swift.Double]
  public static func == (a: Mappy.RouteResponse, b: Mappy.RouteResponse) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
final public class Map : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  final public var packageName: Swift.String?
  public init(mapInfo: any Mappy.MapInfo)
  @objc deinit
}
public enum MapError : Foundation.LocalizedError {
  case objectNotFound
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol MapInfo {
  var venueId: Swift.String { get }
  var region: Mappy.MapRegion { get }
  var maxScale: Swift.Double { get }
  var minScale: Swift.Double { get }
  var initialExtent2DBookmark: Swift.String? { get }
}
public struct MapRegion {
  public let xMin: Swift.Double
  public let yMin: Swift.Double
  public let xMax: Swift.Double
  public let yMax: Swift.Double
  public init(xMin: Swift.Double, yMin: Swift.Double, xMax: Swift.Double, yMax: Swift.Double)
}
extension Mappy.Map {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.MapError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], any Swift.Error>
  final public func getRoutes(from origin: Mappy.Feature, to destination: Mappy.Feature, skiLevel: Mappy.SkiSlope.Level) -> Combine.AnyPublisher<[Mappy.RouteModel], any Swift.Error>
  final public func destroy()
}
public struct Feature : Swift.Identifiable, Swift.Equatable, Swift.Hashable {
  public let id: Foundation.UUID
  public let category: Mappy.FeatureCategory
  public var associatedFeatures: Swift.Set<Mappy.Feature>
  public init(point: Mappy.Point)
  public static func == (a: Mappy.Feature, b: Mappy.Feature) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Foundation.UUID
  public var hashValue: Swift.Int {
    get
  }
}
public struct TurnByTurnNavigationResponse {
  public let route: Mappy.RouteResponse
  public let didReroute: Swift.Bool
  public var currentStep: Mappy.RouteResponse.RouteStep? {
    get
  }
  public var nextStep: Mappy.RouteResponse.RouteStep? {
    get
  }
}
extension Mappy.SceneView {
  @_Concurrency.MainActor(unsafe) final public var isUserTrackRendered: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func renderUserTrack(startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, userId: Swift.String? = nil) -> Combine.AnyPublisher<Mappy.SceneView.UserTrackRenderingStatus, any Swift.Error>
  @_Concurrency.MainActor(unsafe) final public func showUserTrack()
  @_Concurrency.MainActor(unsafe) final public func hideUserTrack()
  @_Concurrency.MainActor(unsafe) final public func removeUserTrack()
  public enum UserTrackRenderingStatus {
    case normal, empty
    public static func == (a: Mappy.SceneView.UserTrackRenderingStatus, b: Mappy.SceneView.UserTrackRenderingStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct RouteStepModel : Swift.Identifiable, Swift.Equatable {
  public let id: Foundation.UUID
  public var ratio: Swift.Int
  public var label: Swift.String
  public var level: Mappy.SkiSlope.Level?
  public static func == (a: Mappy.RouteStepModel, b: Mappy.RouteStepModel) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
public struct NavigationStep : Swift.Identifiable {
  public let id: Foundation.UUID
  public let feature: Mappy.FeatureCategory
  public let duration: Swift.String
  public typealias ID = Foundation.UUID
}
public struct RouteModel : Swift.Identifiable, Swift.Equatable {
  public var id: Foundation.UUID
  public var distance: Swift.Int
  public var distanceFormatted: Swift.String
  public var duration: Swift.Int
  public var level: Mappy.SkiSlope.Level
  public var ratios: [Mappy.RouteStepModel]
  public var routeResponse: Mappy.RouteResponse
  public var levelLabel: Swift.String
  public var startingPoint: Swift.String {
    get
  }
  public var steps: [Mappy.NavigationStep] {
    get
  }
  public var endingPoint: Swift.String {
    get
  }
  public static func == (a: Mappy.RouteModel, b: Mappy.RouteModel) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
public struct DirectionManeuver : Swift.Equatable {
  public var directionEvents: [any Mappy.DirectionEvent] {
    get
  }
  public var directionText: Swift.String {
    get
  }
  public var estimatedArriveTime: Foundation.Date? {
    get
  }
  public var estimatedArrivalTimeShift: Swift.Double {
    get
  }
  public var maneuverMessages: [any Mappy.DirectionMessage] {
    get
  }
  public var fromLevel: Swift.Int {
    get
  }
  public var directionManeuverType: Mappy.DirectionManeuverType {
    get
  }
  public var toLevel: Swift.Int {
    get
  }
  public var length: Swift.Double {
    get
  }
  public var duration: Swift.Double {
    get
  }
  public static func == (a: Mappy.DirectionManeuver, b: Mappy.DirectionManeuver) -> Swift.Bool
}
public protocol DirectionEvent : AnyObject, Swift.Equatable {
  var estimatedArrivalTime: Foundation.Date? { get }
  var estimatedArrivalTimeShift: Swift.Double { get }
  var eventMessages: [Swift.String] { get }
  var eventText: Swift.String { get }
}
extension ArcGIS.AGSDirectionEvent : Mappy.DirectionEvent {
}
public enum DirectionMessageType : Swift.Equatable {
  case unknown
  @available(*, deprecated, message: "directionMessageTypeLength is no longer supported, use directionManeuver.length instead")
  case length
  @available(*, deprecated, message: "directionMessageTypeTime is no longer supported, use directionManeuver.duration instead")
  case time
  @available(*, deprecated, message: "directionMessageTypeSummary is no longer supported, use directionManeuver.duration and directionManeuver.length instead")
  case summary
  @available(*, deprecated, message: "directionMessageTypeTimeWindow is no longer supported, use Stop.timeWindowStart and Stop.timeWindowEnd instead")
  case timeWindow
  @available(*, deprecated, message: "directionMessageTypeViolationTime is no longer supported, use Stop.violationTime instead")
  case violationTime
  @available(*, deprecated, message: "directionMessageTypeWaitTime is no longer supported, use Stop.waitTime instead")
  case waitTime
  @available(*, deprecated, message: "directionMessageTypeServiceTime is no longer supported, use the difference between DirectionManeuver.duration and Stop.waitTime instead")
  case serviceTime
  @available(*, deprecated, message: "directionMessageTypeEstimatedArrivalTime is no longer supported, use DirectionManeuver.estimatedArriveTime instead")
  case estimatedArrivalTime
  @available(*, deprecated, message: "directionMessageTypeCumulativeLength is no longer supported, use the sum of previous DirectionManeuver.length instead")
  case cumulativeLength
  case streetName
  case alternativeName
  case branch
  case toward
  case crossStreet
  case exit
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Mappy.DirectionMessageType, b: Mappy.DirectionMessageType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DirectionMessage : AnyObject, Swift.Equatable {
  var messageType: Mappy.DirectionMessageType { get }
  var text: Swift.String { get }
}
extension ArcGIS.AGSDirectionMessage : Mappy.DirectionMessage {
  public var messageType: Mappy.DirectionMessageType {
    get
  }
}
public enum RegionMonitoringError : Foundation.LocalizedError {
  case maximumMonitoredRegionsExceeded(maxRegions: Swift.Int)
  case invalidGeometry
  case serviceUnavailable
  case regionTooLarge(maxRadius: Swift.Int)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum GroupsProviderError : Foundation.LocalizedError {
  case objectNotFound
  case groupLimitExceeded
  case groupUsersLimitExceeded
  case userNotFound
  case groupNotFound
  case userAlreadyExists
  case groupAlreadyExists
  case groupIsEmpty
  case userAlreadyInGroup
  case userNotInGroup
  case groupCodeInUse
  case groupCodeNotFound
  case invalidPayload
  case underlyingError(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.MapView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
  @_Concurrency.MainActor(unsafe) final public func displayUserPins(using locations: [Mappy.UserPinLocation])
  @_Concurrency.MainActor(unsafe) final public func display(route: Mappy.RouteResponse?, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPinSmall)
  @_Concurrency.MainActor(unsafe) final public func startNavigation(route: Mappy.RouteResponse, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPin) -> Mappy.RouteTracker?
  @_Concurrency.MainActor(unsafe) final public func stopNavigation()
  @_Concurrency.MainActor(unsafe) final public func zoomToLocation(latitude: Swift.Double, longitude: Swift.Double)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class SceneView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var scene: Mappy.Scene? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.SceneView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var interactionOptions: Mappy.SceneViewInteractionOptions {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.SceneView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreFoundation.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.SceneView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
@objc @_inheritsConvenienceInitializers final public class TracksService : ObjectiveC.NSObject, Mappy.TracksProvider {
  @objc override dynamic public init()
  final public func renderUserTracks(on geoModel: ArcGIS.AGSGeoModel, layerId: Swift.String, userId: Swift.String?, venueId: Swift.String, startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval) -> Combine.AnyPublisher<ArcGIS.AGSFeatureLayer, Mappy.TracksProviderError>
  @objc deinit
}
extension Mappy.TracksService : ArcGIS.AGSAuthenticationManagerDelegate {
  @objc final public func authenticationManager(_ authenticationManager: ArcGIS.AGSAuthenticationManager, didReceive challenge: ArcGIS.AGSAuthenticationChallenge)
}
public struct MapViewInteractionOptions {
  public var enabled: Swift.Bool
  public var rotateEnabled: Swift.Bool
  public var panEnabled: Swift.Bool
  public var zoomEnabled: Swift.Bool
  public var magnifierEnabled: Swift.Bool
  public var flickEnabled: Swift.Bool
  public var allowMagnifierToPan: Swift.Bool
  public var zoomFactor: Swift.Double
  public var snapToNorthThreshold: Swift.Double
}
extension Mappy.MapView {
  @_Concurrency.MainActor(unsafe) final public var isUserTrackRendered: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func renderUserTrack(startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, userId: Swift.String? = nil) -> Combine.AnyPublisher<Mappy.MapView.UserTrackRenderingStatus, any Swift.Error>
  @_Concurrency.MainActor(unsafe) final public func showUserTrack()
  @_Concurrency.MainActor(unsafe) final public func hideUserTrack()
  @_Concurrency.MainActor(unsafe) final public func removeUserTrack()
  public enum UserTrackRenderingStatus {
    case normal, empty
    public static func == (a: Mappy.MapView.UserTrackRenderingStatus, b: Mappy.MapView.UserTrackRenderingStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum ValueWrapper : Swift.Codable, Swift.CustomStringConvertible {
  case stringValue(Swift.String)
  case intValue(Swift.Int)
  case doubleValue(Swift.Double)
  case boolValue(Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public var intValue: Swift.Int? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct GroupUser : Swift.Equatable, Swift.Hashable {
  public let userId: Swift.String
  public let location: Mappy.GroupUser.Location?
  public let userRole: Swift.String?
  public struct Location : Swift.Equatable, Swift.Hashable {
    public let unixDate: Foundation.TimeInterval
    public let lat: Swift.Double
    public let long: Swift.Double
    public static func == (a: Mappy.GroupUser.Location, b: Mappy.GroupUser.Location) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func == (a: Mappy.GroupUser, b: Mappy.GroupUser) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Building.Category : Swift.Equatable {}
extension Mappy.Building.Category : Swift.Hashable {}
extension Mappy.Building.Category : Swift.RawRepresentable {}
extension Mappy.DirectionManeuverType : Swift.Equatable {}
extension Mappy.DirectionManeuverType : Swift.Hashable {}
extension Mappy.MapType : Swift.Equatable {}
extension Mappy.MapType : Swift.Hashable {}
extension Mappy.MapType : Swift.RawRepresentable {}
extension Mappy.SkiLift.LiftType : Swift.Equatable {}
extension Mappy.SkiLift.LiftType : Swift.Hashable {}
extension Mappy.SkiLift.LiftType : Swift.RawRepresentable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Equatable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Hashable {}
extension Mappy.SkiLift.PassengerPosition : Swift.RawRepresentable {}
extension Mappy.Bookmark.Category : Swift.Equatable {}
extension Mappy.Bookmark.Category : Swift.Hashable {}
extension Mappy.Bookmark.Category : Swift.RawRepresentable {}
extension Mappy.Environment : Swift.Equatable {}
extension Mappy.Environment : Swift.Hashable {}
extension Mappy.Environment : Swift.RawRepresentable {}
extension Mappy.SkiSlope.Level : Swift.Hashable {}
extension Mappy.SkiSlope.Level : Swift.RawRepresentable {}
extension Mappy.SkiSlope.RunType : Swift.Equatable {}
extension Mappy.SkiSlope.RunType : Swift.Hashable {}
extension Mappy.SkiSlope.RunType : Swift.RawRepresentable {}
extension Mappy.LoadStatus : Swift.Equatable {}
extension Mappy.LoadStatus : Swift.Hashable {}
extension Mappy.RouteResponse.TravelType : Swift.Equatable {}
extension Mappy.RouteResponse.TravelType : Swift.Hashable {}
extension Mappy.SceneView.UserTrackRenderingStatus : Swift.Equatable {}
extension Mappy.SceneView.UserTrackRenderingStatus : Swift.Hashable {}
extension Mappy.DirectionMessageType : Swift.Hashable {}
extension Mappy.MapView.UserTrackRenderingStatus : Swift.Equatable {}
extension Mappy.MapView.UserTrackRenderingStatus : Swift.Hashable {}
