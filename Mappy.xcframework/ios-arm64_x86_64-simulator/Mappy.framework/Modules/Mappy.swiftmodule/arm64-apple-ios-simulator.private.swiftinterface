// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Mappy
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import ArcGIS
import CocoaLumberjack
import CocoaLumberjackSwift
import Combine
import CoreLocation
import Foundation
import KeychainAccess
@_exported import Mappy
import PusherSwift
import Reachability
import Swift
import Swinject
import UIKit
import ZIPFoundation
import _Concurrency
import _StringProcessing
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class MapView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var map: Mappy.Map? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.MapView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var interactionOptions: Mappy.MapViewInteractionOptions {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.MapView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreFoundation.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.MapView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
public struct UserLocation : Mappy.Serializable {
  public let userId: Swift.String
  public let lat: Swift.Double
  public let long: Swift.Double
  public let unixDate: Swift.Double
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct Building : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String {
    case chalet
    case hotelLobby
    case lodge
    case restaurant
    case restroom
    case skiPatrol
    case other
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.Building.Category?
  public let url: Swift.String?
  public let phone: Swift.String?
  public let facilityId: Swift.String?
  public let foreignId: Swift.String?
  public static let any: Mappy.Building
  public init(name: Swift.String, category: Mappy.Building.Category?, url: Swift.String?, phone: Swift.String?, facilityId: Swift.String?, foreignId: Swift.String?)
  public static func == (a: Mappy.Building, b: Mappy.Building) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RouteTracker {
  final public var onEvent: Combine.PassthroughSubject<Mappy.RouteTracker.Event, Swift.Never>
  final public var recentResponse: Mappy.TurnByTurnNavigationResponse?
  final public var voiceDirectionsActive: Swift.Bool {
    get
    set
  }
  final public var currentStep: Mappy.NavigationUpcomingDirection? {
    get
  }
  final public var nextStep: Mappy.NavigationUpcomingDirection? {
    get
  }
  final public var remainingTime: Swift.String {
    get
  }
  final public var routeDifficulty: Mappy.SkiSlope.Level {
    get
  }
  final public var totalRouteDistance: Swift.String {
    get
  }
  final public var startingPoint: Swift.String {
    get
  }
  final public var steps: [Mappy.NavigationStep] {
    get
  }
  final public var endingPoint: Swift.String {
    get
  }
  @objc deinit
}
extension Mappy.RouteTracker {
  public enum Event {
    case onError(Swift.Error)
    case onTurnByTurnNavigationResponse(Mappy.TurnByTurnNavigationResponse)
    case didReroute(Mappy.RouteResponse)
    case didReachDestination
  }
}
public struct NavigationUpcomingDirection {
  public var directionManeuverType: Mappy.DirectionManeuverType {
    get
  }
  public let distance: Swift.String
}
public enum DirectionManeuverType {
  case unknown, stop, straight, bearLeft, bearRight, turnLeft, turnRight, sharpLeft, sharpRight, uTurn, ferry, roundabout, highwayMerge, highwayExit, highwayChange, forkCenter, forkLeft, forkRight, depart, tripItem, endOfFerry, rampRight, rampLeft, turnLeftRight, turnRightLeft, turnRightRight, turnLeftLeft, pedestrianRamp, elevator, escalator, stairs, doorPassage
  public static func == (a: Mappy.DirectionManeuverType, b: Mappy.DirectionManeuverType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Scene {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.SceneError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getRoutes(from origin: Mappy.Feature, to destination: Mappy.Feature, skiLevel: Mappy.SkiSlope.Level) -> Combine.AnyPublisher<[Mappy.RouteModel], Swift.Error>
}
public struct SceneViewInteractionOptions {
}
public struct Group : Swift.Equatable, Swift.Hashable {
  public let groupId: Swift.String
  public let groupCode: Swift.String
  public let name: Swift.String
  public let users: [Mappy.GroupUser]
  public static func == (a: Mappy.Group, b: Mappy.Group) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SkiLift : Swift.Equatable, Swift.Hashable {
  public enum LiftType : Swift.String {
    case magicCarpet
    case towRope
    case chairLift2
    case chairLift3
    case chairLift4
    case chairLift5
    case chairLift6
    case gondola
    case tram
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PassengerPosition : Swift.String {
    case sit
    case stand
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var displayName: Swift.String {
    get
  }
  public let name: Swift.String
  public let liftType: Mappy.SkiLift.LiftType?
  public let passengerPosition: Mappy.SkiLift.PassengerPosition?
  public let length: Swift.Double?
  public let travelTime: Swift.Double?
  public var liftNumber: Swift.Int?
  public let foreignId: Swift.String?
  public static let any: Mappy.SkiLift
  public init(name: Swift.String, liftNumber: Swift.Int?, liftType: Mappy.SkiLift.LiftType?, passengerPosition: Mappy.SkiLift.PassengerPosition?, length: Swift.Double?, travelTime: Swift.Double?, foreignId: Swift.String?)
  public static func == (a: Mappy.SkiLift, b: Mappy.SkiLift) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VenuesService {
  public init()
  public func getVenues() -> Combine.AnyPublisher<[Mappy.Venue], Mappy.VenuesProviderError>
  public func getVenue(venueId: Swift.String) -> Combine.AnyPublisher<Mappy.Venue?, Mappy.VenuesProviderError>
  @objc deinit
}
final public class Scene : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  public init(sceneInfo: Mappy.SceneInfo)
  @objc deinit
}
public enum SceneError : Foundation.LocalizedError {
  case objectNotFound
  case identifierNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol SceneInfo {
  var venueId: Swift.String { get }
}
public protocol Serializable : Swift.Decodable, Swift.Encodable {
  func serialize() -> Foundation.Data?
}
extension Mappy.Serializable {
  public func serialize() -> Foundation.Data?
}
public struct BuildingAmenity : Swift.Equatable, Swift.Hashable {
  public enum Category : Swift.String, Swift.Comparable {
    case foodAndBeverage
    case retail
    case firstAid
    case other
    case accommodations
    case guestServices
    case transportation
    case baseArea
    case skiFeature
    case information
    public static func < (lhs: Mappy.BuildingAmenity.Category, rhs: Mappy.BuildingAmenity.Category) -> Swift.Bool
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Subtype : Swift.String {
    case bar
    case fullService
    case casual
    case ticketOffice
    case rentalShop
    case repairShop
    case retailStore
    case zipTours
    case skiPatrol
    case aed
    case restroom
    case skiSchool
    case kidZones
    case lockers
    case restArea
    case adaAccessible
    case other
    case shuttleStop
    case transportation
    case rentals
    case atm
    case hotel
    case condo
    case information
    case baseArea
    case village
    case villageNoDetail
    case racingArena
    case terrainPark
    case guestServices
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.BuildingAmenity.Category?
  public let subtype: Mappy.BuildingAmenity.Subtype?
  public let buildingId: Swift.Int?
  public let buildingName: Swift.String?
  public let levelId: Swift.String?
  public let url: Swift.String?
  public let phone: Swift.String?
  public let foreignId: Swift.String?
  public static let any: Mappy.BuildingAmenity
  public init(name: Swift.String, category: Mappy.BuildingAmenity.Category?, subtype: Mappy.BuildingAmenity.Subtype?, buildingId: Swift.Int?, buildingName: Swift.String?, levelId: Swift.String?, url: Swift.String?, phone: Swift.String?, foreignId: Swift.String?)
  public static func == (a: Mappy.BuildingAmenity, b: Mappy.BuildingAmenity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Bookmark : Swift.Equatable, Swift.Hashable {
  public static let any: Mappy.Bookmark
  public enum Category : Swift.String {
    case village
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let category: Mappy.Bookmark.Category?
  public let foreignId: Swift.String?
  public static func == (a: Mappy.Bookmark, b: Mappy.Bookmark) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct UserPinLocation {
  public let userId: Swift.String
  public let icon: UIKit.UIImage
  public let name: Swift.String
  public let lat: CoreLocation.CLLocationDegrees
  public let long: CoreLocation.CLLocationDegrees
  public let unixDate: Swift.Double
  public init(userId: Swift.String, icon: UIKit.UIImage, name: Swift.String, lat: CoreLocation.CLLocationDegrees, long: CoreLocation.CLLocationDegrees, unixDate: Swift.Double)
}
public enum FeatureCategory : Swift.Equatable, Swift.Hashable {
  case skiSlope(Mappy.SkiSlope)
  case skiLift(Mappy.SkiLift)
  case building(Mappy.Building)
  case amenity(Mappy.BuildingAmenity)
  case point(Mappy.Point)
  case bookmark(Mappy.Bookmark)
  public var name: Swift.String {
    get
  }
  public static func == (a: Mappy.FeatureCategory, b: Mappy.FeatureCategory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Environment : Swift.String, Mappy.Serializable {
  case DEV, TST, STG, PRD
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class GroupsService {
  public init()
  final public func fetchGroups() -> Combine.AnyPublisher<[Mappy.Group], Mappy.GroupsProviderError>
  final public func fetchGroupInfo(groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func createGroup(name: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func updateGroup(groupId: Swift.String, name: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func deleteGroup(groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func addUser(userId: Swift.String, groupCode: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  final public func removeUser(userId: Swift.String, groupId: Swift.String) -> Combine.AnyPublisher<Mappy.Group, Mappy.GroupsProviderError>
  @objc deinit
}
public class GroupLocationService {
  final public let onEvent: Combine.PassthroughSubject<Mappy.GroupLocationService.Event, Swift.Never>
  public init()
  public func shareUserLocation() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  public func stopSharingUserLocation()
  public func listenToGroups() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  public func stopListeningToGroups() -> Combine.AnyPublisher<Swift.Void, Mappy.GroupLocationServiceError>
  @objc deinit
}
public enum GroupLocationServiceError : Foundation.LocalizedError {
  case objectNotFound
  case clientIdNotFound
  case userIsNotInsideTheVenue
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.GroupLocationService {
  public enum Event {
    case userLocation(Mappy.UserLocation)
  }
}
public struct SkiSlope : Swift.Equatable, Swift.Hashable {
  public enum Level : Swift.Int, Swift.Comparable, Swift.CaseIterable, Swift.Identifiable {
    public static func < (lhs: Mappy.SkiSlope.Level, rhs: Mappy.SkiSlope.Level) -> Swift.Bool
    case beginner, intermediate, advanced, expert
    public var id: Swift.Int {
      get
    }
    public var name: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [Mappy.SkiSlope.Level]
    public typealias ID = Swift.Int
    public typealias RawValue = Swift.Int
    public static var allCases: [Mappy.SkiSlope.Level] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum RunType : Swift.String {
    case walkingPath
    case mainRun
    case connectorTrail
    case nordicTrail
    case catwalk
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let level: Mappy.SkiSlope.Level?
  public let runType: Mappy.SkiSlope.RunType?
  public let length: Swift.Double?
  public let averageSlope: Swift.Double?
  public let averageSpeed: Swift.Double?
  public let travelTime: Swift.Double?
  public let extremeCondition: Swift.Bool?
  public let foreignId: Swift.String?
  public static let any: Mappy.SkiSlope
  public init(name: Swift.String, level: Mappy.SkiSlope.Level?, runType: Mappy.SkiSlope.RunType?, length: Swift.Double?, averageSlope: Swift.Double?, averageSpeed: Swift.Double?, travelTime: Swift.Double?, extremeCondition: Swift.Bool?, foreignId: Swift.String?)
  public static func == (a: Mappy.SkiSlope, b: Mappy.SkiSlope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Loadable {
  var loadStatus: Mappy.LoadStatus { get }
}
public enum LoadStatus {
  case loaded
  case loading
  case failedToLoad
  case notLoaded
  case unknown
  public static func == (a: Mappy.LoadStatus, b: Mappy.LoadStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MappyCore {
  public static func initialize(clientId: Swift.String, secret: Swift.String, mappyUserId: Swift.String?) -> Combine.AnyPublisher<Mappy.MappyMeta, Swift.Never>
  @objc deinit
}
public struct MappyMeta {
  public var mappyUserId: Swift.String?
  public var error: Mappy.MappyCoreError?
}
public enum MappyCoreError : Foundation.LocalizedError {
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct Point : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let latitude: CoreLocation.CLLocationDegrees
  public let longitude: CoreLocation.CLLocationDegrees
  public static let any: Mappy.Point
  public init(name: Swift.String, latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  public static func == (a: Mappy.Point, b: Mappy.Point) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ArcGIS.AGSLocationDataSource : ArcGIS.AGSLocationChangeHandlerDelegate {
  @objc dynamic public func locationDataSource(_ locationDataSource: ArcGIS.AGSLocationDataSource, locationDidChange location: ArcGIS.AGSLocation)
}
extension UIKit.UIImage {
  public static let mappyPinSmall: UIKit.UIImage
  public static let mappyPin: UIKit.UIImage
}
public struct Venue {
  public let venueId: Swift.String
  public let data: Mappy.VenueData?
}
public struct VenueData {
  public let baseElevation: Swift.Int?
  public let gondolaCount: Swift.Int?
  public let skiableArea: Swift.Int?
  public let skiPatrolEmergencyNumber: Swift.String?
  public let terrainParkCount: Swift.Int?
  public let verticalElevation: Swift.Int?
  public let ziplineCount: Swift.Int?
  public let liftCount: Swift.Int?
  public let name: Swift.String?
  public let description: Swift.String?
  public let geoReference: Mappy.VenueGeoReference?
  public let terrainPercentage: Mappy.VenueTerrainPercentage?
  public let queryParamResortName: Swift.String?
}
public struct VenueGeoReference {
  public let minY: Swift.Double?
  public let minX: Swift.Double?
  public let maxY: Swift.Double?
  public let maxX: Swift.Double?
}
public struct VenueTerrainPercentage {
  public let intermediate: Swift.Float?
  public let advanced: Swift.Float?
  public let beginer: Swift.Float?
}
public enum MapType : Swift.String {
  case map
  case scene
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Mappy.Venue : Mappy.MapInfo, Mappy.SceneInfo {
  public var region: Mappy.MapRegion {
    get
  }
}
public enum VenuesProviderError : Foundation.LocalizedError {
  case objectNotFound
  case venuesNotFound
  case venueNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.SceneView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
  @_Concurrency.MainActor(unsafe) final public func displayUserPins(using locations: [Mappy.UserPinLocation])
  @_Concurrency.MainActor(unsafe) final public func display(route: Mappy.RouteResponse?, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPinSmall)
  @_Concurrency.MainActor(unsafe) final public func startNavigation(route: Mappy.RouteResponse, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPin) -> Mappy.RouteTracker?
  @_Concurrency.MainActor(unsafe) final public func stopNavigation()
}
extension UIKit.UIColor {
  public static let routeHighlight: UIKit.UIColor
  public func withSaturation(setTo saturation: CoreFoundation.CGFloat) -> UIKit.UIColor
}
public struct RouteResponse : Swift.Identifiable, Swift.Equatable {
  public struct RouteStep : Swift.Equatable {
    public var directionManeuver: Mappy.DirectionManeuver {
      get
    }
    public let feature: Mappy.FeatureCategory
    public static func == (a: Mappy.RouteResponse.RouteStep, b: Mappy.RouteResponse.RouteStep) -> Swift.Bool
  }
  public enum TravelType : Swift.CaseIterable {
    case beginner, intermediate, advanced, expert, lift
    public static func == (a: Mappy.RouteResponse.TravelType, b: Mappy.RouteResponse.TravelType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Mappy.RouteResponse.TravelType]
    public static var allCases: [Mappy.RouteResponse.TravelType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let id: Foundation.UUID
  public let origin: Mappy.Feature
  public let destination: Mappy.Feature
  public let steps: [Mappy.RouteResponse.RouteStep]
  public func mostDifficultSkiSlopeLevel() -> Mappy.SkiSlope.Level
  public func travelTypeRatiosByDuration() -> [Mappy.RouteResponse.TravelType : Swift.Double]
  public static func == (a: Mappy.RouteResponse, b: Mappy.RouteResponse) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
final public class Map : Mappy.Loadable {
  final public var loadStatus: Mappy.LoadStatus {
    get
  }
  public init(mapInfo: Mappy.MapInfo)
  @objc deinit
}
public enum MapError : Foundation.LocalizedError {
  case objectNotFound
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol MapInfo {
  var venueId: Swift.String { get }
  var region: Mappy.MapRegion { get }
}
public struct MapRegion {
}
extension Mappy.Map {
  final public func load() -> Combine.AnyPublisher<Swift.Void, Mappy.MapError>
  final public func getFeatures() -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(category: Mappy.FeatureCategory) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getFeatures(text: Swift.String, categories: [Mappy.FeatureCategory]? = nil) -> Combine.AnyPublisher<[Mappy.Feature], Swift.Error>
  final public func getRoutes(from origin: Mappy.Feature, to destination: Mappy.Feature, skiLevel: Mappy.SkiSlope.Level) -> Combine.AnyPublisher<[Mappy.RouteModel], Swift.Error>
}
public struct Feature : Swift.Identifiable, Swift.Equatable, Swift.Hashable {
  public let id: Foundation.UUID
  public let category: Mappy.FeatureCategory
  public var associatedFeatures: Swift.Set<Mappy.Feature>
  public init(point: Mappy.Point)
  public static func == (a: Mappy.Feature, b: Mappy.Feature) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Foundation.UUID
  public var hashValue: Swift.Int {
    get
  }
}
public struct TurnByTurnNavigationResponse {
  public let route: Mappy.RouteResponse
  public let didReroute: Swift.Bool
  public var currentStep: Mappy.RouteResponse.RouteStep? {
    get
  }
  public var nextStep: Mappy.RouteResponse.RouteStep? {
    get
  }
}
public struct RouteStepModel : Swift.Identifiable, Swift.Equatable {
  public let id: Foundation.UUID
  public var ratio: Swift.Int
  public var label: Swift.String
  public var level: Mappy.SkiSlope.Level?
  public static func == (a: Mappy.RouteStepModel, b: Mappy.RouteStepModel) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
public struct NavigationStep : Swift.Identifiable {
  public let id: Foundation.UUID
  public let feature: Mappy.FeatureCategory
  public let duration: Swift.String
  public typealias ID = Foundation.UUID
}
public struct RouteModel : Swift.Identifiable, Swift.Equatable {
  public var id: Foundation.UUID
  public var distance: Swift.Int
  public var distanceFormatted: Swift.String
  public var duration: Swift.Int
  public var level: Mappy.SkiSlope.Level
  public var ratios: [Mappy.RouteStepModel]
  public var routeResponse: Mappy.RouteResponse
  public var levelLabel: Swift.String
  public var startingPoint: Swift.String {
    get
  }
  public var steps: [Mappy.NavigationStep] {
    get
  }
  public var endingPoint: Swift.String {
    get
  }
  public static func == (a: Mappy.RouteModel, b: Mappy.RouteModel) -> Swift.Bool
  public typealias ID = Foundation.UUID
}
public struct DirectionManeuver : Swift.Equatable {
  public var directionEvents: [Mappy.DirectionEvent] {
    get
  }
  public var directionText: Swift.String {
    get
  }
  public var estimatedArriveTime: Foundation.Date? {
    get
  }
  public var estimatedArrivalTimeShift: Swift.Double {
    get
  }
  public var maneuverMessages: [Mappy.DirectionMessage] {
    get
  }
  public var fromLevel: Swift.Int {
    get
  }
  public var directionManeuverType: Mappy.DirectionManeuverType {
    get
  }
  public var toLevel: Swift.Int {
    get
  }
  public var length: Swift.Double {
    get
  }
  public var duration: Swift.Double {
    get
  }
  public static func == (a: Mappy.DirectionManeuver, b: Mappy.DirectionManeuver) -> Swift.Bool
}
public protocol DirectionEvent : AnyObject, Swift.Equatable {
  var estimatedArrivalTime: Foundation.Date? { get }
  var estimatedArrivalTimeShift: Swift.Double { get }
  var eventMessages: [Swift.String] { get }
  var eventText: Swift.String { get }
}
extension ArcGIS.AGSDirectionEvent : Mappy.DirectionEvent {
}
public enum DirectionMessageType : Swift.Equatable {
  case unknown
  @available(*, deprecated, message: "directionMessageTypeLength is no longer supported, use directionManeuver.length instead")
  case length
  @available(*, deprecated, message: "directionMessageTypeTime is no longer supported, use directionManeuver.duration instead")
  case time
  @available(*, deprecated, message: "directionMessageTypeSummary is no longer supported, use directionManeuver.duration and directionManeuver.length instead")
  case summary
  @available(*, deprecated, message: "directionMessageTypeTimeWindow is no longer supported, use Stop.timeWindowStart and Stop.timeWindowEnd instead")
  case timeWindow
  @available(*, deprecated, message: "directionMessageTypeViolationTime is no longer supported, use Stop.violationTime instead")
  case violationTime
  @available(*, deprecated, message: "directionMessageTypeWaitTime is no longer supported, use Stop.waitTime instead")
  case waitTime
  @available(*, deprecated, message: "directionMessageTypeServiceTime is no longer supported, use the difference between DirectionManeuver.duration and Stop.waitTime instead")
  case serviceTime
  @available(*, deprecated, message: "directionMessageTypeEstimatedArrivalTime is no longer supported, use DirectionManeuver.estimatedArriveTime instead")
  case estimatedArrivalTime
  @available(*, deprecated, message: "directionMessageTypeCumulativeLength is no longer supported, use the sum of previous DirectionManeuver.length instead")
  case cumulativeLength
  case streetName
  case alternativeName
  case branch
  case toward
  case crossStreet
  case exit
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Mappy.DirectionMessageType, b: Mappy.DirectionMessageType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DirectionMessage : AnyObject, Swift.Equatable {
  var messageType: Mappy.DirectionMessageType { get }
  var text: Swift.String { get }
}
extension ArcGIS.AGSDirectionMessage : Mappy.DirectionMessage {
  public var messageType: Mappy.DirectionMessageType {
    get
  }
}
public enum GroupsProviderError : Foundation.LocalizedError {
  case objectNotFound
  case groupLimitExceeded
  case groupUsersLimitExceeded
  case userNotFound
  case groupNotFound
  case userAlreadyExists
  case groupAlreadyExists
  case groupIsEmpty
  case userAlreadyInGroup
  case userNotInGroup
  case groupCodeInUse
  case groupCodeNotFound
  case invalidPayload
  case underlyingError(Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Mappy.MapView {
  @_Concurrency.MainActor(unsafe) final public func setInitialViewpoint()
  @_Concurrency.MainActor(unsafe) final public func rotateToNorth()
  @_Concurrency.MainActor(unsafe) final public func select(feature: Mappy.Feature?)
  @_Concurrency.MainActor(unsafe) final public func displayUserPins(using locations: [Mappy.UserPinLocation])
  @_Concurrency.MainActor(unsafe) final public func display(route: Mappy.RouteResponse?, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPinSmall)
  @_Concurrency.MainActor(unsafe) final public func startNavigation(route: Mappy.RouteResponse, routeHighlightColor: UIKit.UIColor = .routeHighlight, destinationImage: UIKit.UIImage = .mappyPin) -> Mappy.RouteTracker?
  @_Concurrency.MainActor(unsafe) final public func stopNavigation()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class SceneView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var scene: Mappy.Scene? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let event: Combine.PassthroughSubject<Mappy.SceneView.Event, Swift.Never>
  @_Concurrency.MainActor(unsafe) final public var isPointingNorth: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var interactionOptions: Mappy.SceneViewInteractionOptions {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Mappy.SceneView : ArcGIS.AGSGeoViewTouchDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func geoView(_ geoView: ArcGIS.AGSGeoView, didTapAtScreenPoint screenPoint: CoreFoundation.CGPoint, mapPoint: ArcGIS.AGSPoint)
}
extension Mappy.SceneView {
  public enum Event {
    case onViewpointChange
    case onTap(Mappy.Feature?)
  }
}
public struct MapViewInteractionOptions {
  public var enabled: Swift.Bool
  public var rotateEnabled: Swift.Bool
  public var panEnabled: Swift.Bool
  public var zoomEnabled: Swift.Bool
  public var magnifierEnabled: Swift.Bool
  public var flickEnabled: Swift.Bool
  public var allowMagnifierToPan: Swift.Bool
  public var zoomFactor: Swift.Double
  public var snapToNorthThreshold: Swift.Double
}
public struct GroupUser : Swift.Equatable, Swift.Hashable {
  public let userId: Swift.String
  public let location: Mappy.GroupUser.Location?
  public struct Location : Swift.Equatable, Swift.Hashable {
    public let unixDate: Foundation.TimeInterval
    public let lat: Swift.Double
    public let long: Swift.Double
    public static func == (a: Mappy.GroupUser.Location, b: Mappy.GroupUser.Location) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func == (a: Mappy.GroupUser, b: Mappy.GroupUser) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Mappy.Building.Category : Swift.Equatable {}
extension Mappy.Building.Category : Swift.Hashable {}
extension Mappy.Building.Category : Swift.RawRepresentable {}
extension Mappy.DirectionManeuverType : Swift.Equatable {}
extension Mappy.DirectionManeuverType : Swift.Hashable {}
extension Mappy.MapType : Swift.Equatable {}
extension Mappy.MapType : Swift.Hashable {}
extension Mappy.MapType : Swift.RawRepresentable {}
extension Mappy.SkiLift.LiftType : Swift.Equatable {}
extension Mappy.SkiLift.LiftType : Swift.Hashable {}
extension Mappy.SkiLift.LiftType : Swift.RawRepresentable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Equatable {}
extension Mappy.SkiLift.PassengerPosition : Swift.Hashable {}
extension Mappy.SkiLift.PassengerPosition : Swift.RawRepresentable {}
extension Mappy.BuildingAmenity.Category : Swift.Hashable {}
extension Mappy.BuildingAmenity.Category : Swift.RawRepresentable {}
extension Mappy.BuildingAmenity.Subtype : Swift.Equatable {}
extension Mappy.BuildingAmenity.Subtype : Swift.Hashable {}
extension Mappy.BuildingAmenity.Subtype : Swift.RawRepresentable {}
extension Mappy.Bookmark.Category : Swift.Equatable {}
extension Mappy.Bookmark.Category : Swift.Hashable {}
extension Mappy.Bookmark.Category : Swift.RawRepresentable {}
extension Mappy.Environment : Swift.Equatable {}
extension Mappy.Environment : Swift.Hashable {}
extension Mappy.Environment : Swift.RawRepresentable {}
extension Mappy.SkiSlope.Level : Swift.Hashable {}
extension Mappy.SkiSlope.Level : Swift.RawRepresentable {}
extension Mappy.SkiSlope.RunType : Swift.Equatable {}
extension Mappy.SkiSlope.RunType : Swift.Hashable {}
extension Mappy.SkiSlope.RunType : Swift.RawRepresentable {}
extension Mappy.LoadStatus : Swift.Equatable {}
extension Mappy.LoadStatus : Swift.Hashable {}
extension Mappy.RouteResponse.TravelType : Swift.Equatable {}
extension Mappy.RouteResponse.TravelType : Swift.Hashable {}
extension Mappy.DirectionMessageType : Swift.Hashable {}
